![run-tests](../../workflows/run-tests/badge.svg)

## 2023 Project 2

Εκφώνηση: https://k08.chatzi.org/projects/project2/


### Προσωπικά στοιχεία

__Όνομα__: Τζαφέρης Στέφανος

__Α.Μ.__: sdi2200183

### Ασκήσεις που παραδίδονται

Συμπληρώστε εδώ τις ασκήσεις (και τυχόν bonus) που παραδίδετε. Αν κάποια άσκηση
βρίσκεται σε μη αναμενόμενα αρχεία αναφέρετε και τα αρχεία αυτά.

- Ασκηση 1.
- Ασκηση 2.
- Ασκηση 3.
- Ασκηση 4.
- Ασκηση 5. 

### Documentation

Συμπληρώστε εδώ __όσο documentation χρειάζεται__ ώστε οι βαθμολογητές να
κατανοήσουν πλήρως τις λύσεις σας και να τις βαθμολογήσουν ανάλογα. Αυτό θα
πρέπει να γίνει ανεξάρτητα με το αν ο κώδικάς σας είναι καλά σχολιασμένος,
πράγμα που συνιστάται.


Στο Makefile των test έχω φτιάξει τα test που αναφέρονται σε κάθε άσκηση,μόνο που στο τέλος
κάθε εκτελέσιμου που δημιουργείται εχω προσθέσει στο τέλος του ονόματος ενα suffix (πχ EX_5)
για να φαίνεται πιο εύκολα ποιο test είναι και στο τέλος (map η linked_tree) για να φαίνεται ποια
υλοποίηση χρησημοποιείται.

Ασκηση 1:

    Στην άσκηση 1 ,όταν καταστρέφεται ένα δεντρο αποδεσμεύεται ο χώρος του δέντρου
    αυτού όχι των υποδέντρων του όπως αναφέρεται και στην εκφώνηση για αυτό στα test
    κάνω 4 destroy

Άσκηση 2:

    H πολυπλοκότητα της κάθε συνάρτησης εξαρτάται απο τις πολυπλοκότητες
    των συναρτήσεων του map που με την σειρά τους εξαρτώνται απο τα set 
    τα οποία είναι υλοποιημένα με AVL δεντρα ΑΡΑ:

   -- rectree_create :χρησημοποιει την map_create(set_create O(1)),την map_insert
        O(h = logn) αφου το δεντρο ειναι ΑVL,τελος την map_find Ο(h = logn).
        Αρα η πολυπλοκοτητα βγαινει O(h = (logn )).

   -- rectree_size :O(h = logn) χρησημοποιειται μονο η map_find                       map_find (αναζητηση σε AVL Δεντρο 
        η υπολοιπη δουλεια γινεται στην create.                                       αρα balanced)  O(logn)

   -- rectree_left - rectree_right :O(h = logn) χρησημοποιειται μονο η map_find

   -- rectree_value :O(h = logn) χρησημοποιειται μονο η map_find

   -- rectree_destroy :χρησημοποιει την map_size O(1), την map_remove Ο(h = logn)
        οπου h = logn λόγω AVL υλοποίσης.Και κάποιες φορες (πολυ λίγες),την map_destroy
        O(n).Όμως πολυ λιγες φορες δεν θα υπάρχει όντως κανενα δεντρο αρα θα μπορουσαμε 
        να πουμε οτι εχει:
        
        Amortized: O(logn)
        real: O(n) 

Συγκριτκά με την πρώτη υλοποίηση προφανώς οι συναρτήσεις είναι χειρότερης πολυπλοκότητας
αφου στην πρώτη είναι ολες Ο(1)


Άσκηση 3:
   
    -- rectree_get_subtree : O(h) αφου καλειται αναδρομικα μεχρι την ριζα
        αυτο μπορει να σημαίνει είτε O(logn),σε balanced δεντρο, είτε O(n) αν 
        το δέντρο μοιάζει με εκφυλισμένη λίστα οποτε αναλυτικοτερα:
        
        
        Worst case: O(n) 

    (υποθέτουμε οτι οι συναρτησεις του RecTree.h ειναι Ο(1) οπως στην υλοποιηση
    με linked tree.)
    -- rectree_replace_subtree: Γινεται ενα while απο εναν κομβο μεχρι την ριζα
    αρα στην χειροτερη h βηματα.Mεσα στο while καλουνται οι συναρτησεις rectree_destroy ,
    rectree create που εχουμε υποθεσει οτι ειναι O(1) και η rectree_get_subtree Ο(h).
    Αρα ειναι Ο(h^2)οπου το h οπως προαναφέραμε ειναι h=n σε πολυ λίγες περιπτώσεις μόνο

    Mε την υλοποιηση του map απλα θα πρεπει να λαβουμε υποψην μας και τις αντιστοιχες πολυπλοκοτητες
    Παλι ισχυει οτι worst case πολυπλοκοτητα μπορει να ειναι o(n^2)

Άσκηση 4:

    Oι συναρτήσεις CompTree comptree_create , comptree_size,
    comptree_destroy, comptree_value, comptree_left, comptree_right
    comptree_get_subtree , comptree_replace_subtree

    έχουν τις ίδιες πολυπλοκότητες με τις αντίστοιχες rectree συναρτησεις
    (ανάλογα και με ποια υλοποιηση κανουμε Link)
    αφου μονο τις καλουν και κανουν cast.


    -- comptree_insert_last: Καλει την comptree_create πολυπλοκοτητας Ο(1),υποθετουμε
       οτι χρησημοποιει την υλοποιηση με linked tree και την rectree_replace_subtree O(h^2)

    -- comptree_remove_last: χρησημοποιει μονο την rectree_replace_subtree
       αρα ιδιας πολυπλοκοτητας με αυτην








